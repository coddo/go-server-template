package auth

import (
	"errors"
	"gost/auth/cookies"
	"gost/orm/models"
	"gost/util"
)

// The keys that are used in the request header to authorize the user
const (
	AuthorizationHeader = "Authorization"
	AuthorizationScheme = "GHOST-TOKEN"
)

// Errors generated by the auth package
var (
	ErrInexistentToken = errors.New("The given token is either expired or invalid")
)

// CreateToken generates a new gost-token, saves it in the database and returns it to the client
func CreateToken(user *models.ApplicationUser, client *cookies.Client) (string, error) {
	session, err := cookies.NewSession(user, client)
	if err != nil {
		return "", err
	}

	return encodeToken(session)
}

// Authorize tries to authorize an existing gostToken
func Authorize(gostToken string) (string, error) {
	encryptedToken, err := util.Decode([]byte(gostToken))
	if err != nil {
		return "", err
	}

	jsonToken, err := util.Decrypt(encryptedToken)
	if err != nil {
		return "", err
	}

	var cookie *cookies.Session
	err = util.DeserializeJSON(jsonToken, cookie)
	if err != nil {
		return "", err
	}

	if cookie.IsExpired() {
		return "", cookies.ErrTokenExpired
	}

	dbCookie, err := cookies.GetSession(cookie.Token)
	if err != nil || dbCookie == nil {
		return "", ErrInexistentToken
	}

	cookie.ResetToken()
	return encodeToken(cookie)
}

func encodeToken(session *cookies.Session) (string, error) {
	err := session.Save()
	if err != nil {
		return "", err
	}

	jsonToken, err := util.SerializeJSON(session)
	if err != nil {
		return "", err
	}

	encryptedToken, err := util.Encrypt(jsonToken)
	if err != nil {
		return "", err
	}

	gostToken := util.Encode(encryptedToken)

	return string(gostToken), nil
}
