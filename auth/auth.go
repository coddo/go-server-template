package auth

import (
	"errors"
	"gost/auth/cookies"
	"gost/auth/identity"
	"gost/util"
	"log"
	"net/http"
	"strings"

	"gopkg.in/mgo.v2/bson"
)

// The keys that are used in the request header to authorize the user
const (
	AuthorizationHeader = "Authorization"
	AuthorizationScheme = "GHOST-TOKEN"
)

// Errors generated by the auth package
var (
	ErrInvalidScheme           = errors.New("The used authorization scheme is invalid or not supported")
	ErrInvalidToken            = errors.New("The given token is expired or invalid")
	ErrInvalidUser             = errors.New("There is no application user with the given ID")
	ErrAnonymousUser           = errors.New("The user has no identity")
	ErrInexistentClientDetails = errors.New("Missing client details. Cannot create authorization for anonymous client")
)

// GenerateUserAuth generates a new gost-token, saves it in the database and returns it to the client
func GenerateUserAuth(userID bson.ObjectId, client *cookies.Client) (string, error) {
	if client == nil {
		return ErrInexistentClientDetails.Error(), ErrInexistentClientDetails
	}

	if !identity.IsUserExistent(userID) {
		return ErrInvalidUser.Error(), ErrInvalidUser
	}

	session, err := cookies.NewSession(userID, client)
	if err != nil {
		return err.Error(), err
	}

	return encodeToken(session)
}

// Authorize tries to authorize an existing gostToken
func Authorize(httpHeader http.Header) (*identity.Identity, error) {
	gostToken, err := extractGostToken(httpHeader)
	if err != nil {
		if err == ErrAnonymousUser {
			return identity.NewAnonymous(), nil
		}

		return nil, err
	}

	encryptedToken, err := util.Decode([]byte(gostToken))
	log.Println("ENCRYPTED TOKEN:", encryptedToken, err)
	if err != nil {
		return nil, err
	}

	jsonToken, err := util.Decrypt(encryptedToken)
	log.Println("JSON TOKEN:", jsonToken, err)
	if err != nil {
		return nil, err
	}

	var cookie *cookies.Session
	err = util.DeserializeJSON(jsonToken, cookie)
	log.Println("COOKIE:", cookie, err)
	if err != nil {
		return nil, err
	}

	if cookie.IsExpired() {
		log.Println("COOKIE HAS EXPIRED!")
		return nil, cookies.ErrTokenExpired
	}

	dbCookie, err := cookies.GetSession(cookie.Token)
	log.Println("DATABASE COOKIE:", dbCookie, err)
	if err != nil || dbCookie == nil {
		return nil, ErrInvalidToken
	}

	cookie.ResetToken()
	log.Println("COOKIE AFTER RESET:", cookie, err)

	return identity.New(cookie), nil
}

func extractGostToken(httpHeader http.Header) (string, error) {
	var gostToken string

	if gostToken = httpHeader.Get(AuthorizationHeader); len(gostToken) == 0 {
		return ErrAnonymousUser.Error(), ErrAnonymousUser
	}

	if !strings.Contains(gostToken, AuthorizationScheme) {
		return ErrInvalidScheme.Error(), ErrInvalidScheme
	}

	gostTokenValue := strings.TrimPrefix(gostToken, AuthorizationScheme)
	gostTokenValue = strings.TrimSpace(gostTokenValue)

	if len(gostTokenValue) == 0 {
		return ErrInvalidToken.Error(), ErrInvalidToken
	}

	return gostTokenValue, nil
}

func encodeToken(session *cookies.Session) (string, error) {
	err := session.Save()
	if err != nil {
		return err.Error(), err
	}

	jsonToken, err := util.SerializeJSON(session)
	if err != nil {
		return err.Error(), err
	}

	encryptedToken, err := util.Encrypt(jsonToken)
	if err != nil {
		return err.Error(), err
	}

	gostToken := util.Encode(encryptedToken)

	return string(gostToken), nil
}
